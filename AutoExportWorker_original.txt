package com.example.healthconnectsample.worker

import android.content.Context
import android.os.Environment
import android.util.Log
import androidx.health.connect.client.HealthConnectClient
import androidx.health.connect.client.changes.DeletionChange
import androidx.health.connect.client.changes.UpsertionChange
import androidx.health.connect.client.permission.HealthPermission
import androidx.health.connect.client.records.ExerciseSessionRecord
import androidx.health.connect.client.records.SleepSessionRecord
import androidx.health.connect.client.records.Vo2MaxRecord
import androidx.health.connect.client.records.WeightRecord
import androidx.health.connect.client.request.ChangesTokenRequest
import androidx.health.connect.client.request.ReadRecordsRequest
import androidx.health.connect.client.time.TimeRangeFilter
import androidx.work.CoroutineWorker
import androidx.work.WorkerParameters
import com.example.healthconnectsample.data.HealthConnectManager
import com.example.healthconnectsample.data.HealthDataSerializer
import com.example.healthconnectsample.data.WeightData
import com.example.healthconnectsample.data.dateTimeWithOffsetOrDefault
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import java.io.File
import java.io.FileWriter
import java.time.Instant
import java.time.LocalDateTime
import java.time.ZoneId
import java.time.format.DateTimeFormatter
import kotlin.reflect.KClass

class AutoExportWorker(
    private val context: Context,
    params: WorkerParameters
) : CoroutineWorker(context, params) {

    companion object {
        private const val TAG = "AutoExportWorker"
        private const val EXPORT_FOLDER = "HealthConnectExports"
    }

    private val tokenManager = ChangeTokenManager(context)

    override suspend fun doWork(): Result = withContext(Dispatchers.IO) {
        try {
            Log.d(TAG, "========================================")
            Log.d(TAG, "üöÄ AutoExportWorker INICIADO")
            Log.d(TAG, "========================================")
            Log.d(TAG, "Iniciando export autom√°tico 24/7...")

            if (HealthConnectClient.getSdkStatus(context) != HealthConnectClient.SDK_AVAILABLE) {
                Log.e(TAG, "‚ùå Health Connect no disponible")
                return@withContext Result.retry()
            }

            val healthConnectClient = HealthConnectClient.getOrCreate(context)
            Log.d(TAG, "‚úÖ HealthConnectClient creado")

            val grantedPermissions = healthConnectClient.permissionController.getGrantedPermissions()
            val requiredPermissions = setOf(
                HealthPermission.getReadPermission(WeightRecord::class),
                HealthPermission.getReadPermission(ExerciseSessionRecord::class),
                HealthPermission.getReadPermission(SleepSessionRecord::class),
                HealthPermission.getReadPermission(Vo2MaxRecord::class)
            )

            Log.d(TAG, "Permisos otorgados: ${grantedPermissions.size}")
            Log.d(TAG, "Permisos requeridos: ${requiredPermissions.size}")

            if (!grantedPermissions.containsAll(requiredPermissions)) {
                Log.e(TAG, "‚ùå Permisos no otorgados")
                return@withContext Result.failure()
            }

            val isFirstExport = tokenManager.isFirstExport()
            Log.d(TAG, "¬øEs primer export?: $isFirstExport")

            if (isFirstExport) {
                Log.d(TAG, "üì¶ Primera ejecuci√≥n - Export completo + guardando token")
                performFullExport(healthConnectClient)
            } else {
                Log.d(TAG, "üìù Export incremental - Solo cambios desde √∫ltimo export")
                performDifferentialExport(healthConnectClient)
            }

            Log.d(TAG, "‚úÖ Export completado exitosamente")
            return@withContext Result.success()

        } catch (e: Exception) {
            Log.e(TAG, "‚ùå Error en export autom√°tico", e)
            Log.e(TAG, "Stacktrace: ${e.stackTraceToString()}")
            return@withContext Result.retry()
        }
    }

    private suspend fun performFullExport(client: HealthConnectClient) {
        Log.d(TAG, "Iniciando FULL export...")
        val healthConnectManager = HealthConnectManager(context)

        val endTime = Instant.now()
        val startTime = Instant.EPOCH

        // LECTURA Y FILTRADO DE EJERCICIO
        val allExerciseRecords = healthConnectManager.readExerciseSessions(startTime, endTime)
        val exerciseData = allExerciseRecords.filter { it.metadata.dataOrigin.packageName == "com.sec.android.app.shealth" }
            .mapNotNull { exerciseRecord ->
                val sessionData = try { healthConnectManager.readAssociatedSessionData(exerciseRecord.metadata.id) } catch (e: Exception) { null }
                if (sessionData == null) null else exerciseRecord.toExportMap(sessionData, ::getExerciseTypeName, ::getExerciseTypeEmoji)
            }

        // LECTURA Y FILTRADO DE SUE√ëO
        val allSleepRecords = healthConnectManager.readSleepSessions(startTime, endTime)
        val sleepData = allSleepRecords.filter { it.metadata.dataOrigin.packageName == "com.sec.android.app.shealth" }
            .map { sleepRecord -> sleepRecord.toExportMap(HealthDataSerializer::getSleepStageName) }

        // LECTURA Y FILTRADO DE PESO
        val allWeightRecords = healthConnectManager.readWeightInputs(startTime, endTime)
        val weightRecords = allWeightRecords.filter { it.metadata.dataOrigin.packageName == "com.sec.android.app.shealth" }
            .map { record ->
                WeightData(
                    weight = record.weight,
                    id = record.metadata.id,
                    time = dateTimeWithOffsetOrDefault(record.time, record.zoneOffset),
                    sourceAppInfo = healthConnectManager.healthConnectCompatibleApps[record.metadata.dataOrigin.packageName]
                )
            }

        // LECTURA Y FILTRADO DE VO2 MAX
        val allVo2MaxRecords = healthConnectManager.readVo2MaxRecords(startTime, endTime)
        val vo2MaxRecords = allVo2MaxRecords.filter { it.metadata.dataOrigin.packageName == "com.sec.android.app.shealth" }


        val timestamp = LocalDateTime.now().format(DateTimeFormatter.ofPattern("yyyy-MM-dd_HH-mm"))
        val fileName = "health_data_AUTO_FULL_${timestamp}.json"

        // LLAMADA AL SERIALIZADOR GLOBAL (HealthDataSerializer)
        val jsonContent = HealthDataSerializer.generateHealthJSON(
            weightRecords,
            exerciseData,
            sleepData,
            vo2MaxRecords,
            "AUTO_FULL_EXPORT"
        )

        saveToDownloads(fileName, jsonContent)

        val token = client.getChangesToken(
            ChangesTokenRequest(
                recordTypes = setOf(
                    WeightRecord::class,
                    ExerciseSessionRecord::class,
                    SleepSessionRecord::class,
                    Vo2MaxRecord::class
                )
            )
        )
        tokenManager.saveChangesToken(token)

        Log.d(TAG, "‚úÖ Export completo: ${weightRecords.size} weight + ${exerciseData.size} exercises + ${sleepData.size} sleep + ${vo2MaxRecords.size} VO2 Max")
        Log.d(TAG, "Token guardado para pr√≥ximos exports incrementales")
    }

    private suspend fun performDifferentialExport(client: HealthConnectClient) {
        Log.d(TAG, "Iniciando DIFFERENTIAL export...")

        val savedToken = tokenManager.getChangesToken() ?: run {
            Log.e(TAG, "Token no encontrado, forzando export completo")
            performFullExport(client)
            return
        }

        Log.d(TAG, "Token encontrado, leyendo cambios...")

        val changesResponse = client.getChanges(savedToken)
        Log.d(TAG, "Cambios recibidos: ${changesResponse.changes.size}")

        val weightChanges = mutableListOf<Map<String, Any?>>()
        val exerciseChanges = mutableListOf<Map<String, Any?>>()
        val sleepChanges = mutableListOf<Map<String, Any?>>()
        val vo2MaxChanges = mutableListOf<Map<String, Any?>>()
        val deletions = mutableListOf<String>()

        val healthConnectManager = HealthConnectManager(context)

        changesResponse.changes.forEach { change ->
            when (change) {
                is UpsertionChange -> {
                    when (val record = change.record) {
                        is WeightRecord -> {
                            if (record.metadata.dataOrigin.packageName == "com.sec.android.app.shealth") {
                                weightChanges.add(mapOf(
                                    "timestamp" to record.time.toString(),
                                    "weight_kg" to record.weight.inKilograms,
                                    "source" to record.metadata.dataOrigin.packageName,
                                    "change_type" to "UPSERT"
                                ))
                                Log.d(TAG, "  + Weight change detected")
                            }
                        }
                        is ExerciseSessionRecord -> {
                            if (record.metadata.dataOrigin.packageName == "com.sec.android.app.shealth") {
                                val durationMinutes = try {
                                    java.time.Duration.between(record.startTime, record.endTime).toMinutes()
                                } catch (e: Exception) { 0L }

                                if (durationMinutes >= 2) {
                                    val sessionData = try {
                                        healthConnectManager.readAssociatedSessionData(record.metadata.id)
                                    } catch (e: Exception) { null }

                                    if (sessionData != null) {
                                        exerciseChanges.add(record.toExportMap(sessionData, ::getExerciseTypeName, ::getExerciseTypeEmoji))
                                        Log.d(TAG, "  + Exercise change detected")
                                    }
                                }
                            }
                        }
                        is SleepSessionRecord -> {
                            if (record.metadata.dataOrigin.packageName == "com.sec.android.app.shealth") {
                                sleepChanges.add(record.toExportMap(HealthDataSerializer::getSleepStageName))
                                Log.d(TAG, "  + Sleep change detected")
                            }
                        }
                        is Vo2MaxRecord -> {
                            if (record.metadata.dataOrigin.packageName == "com.sec.android.app.shealth") {
                                vo2MaxChanges.add(mapOf(
                                    "timestamp" to record.time.toString(),
                                    // CORRECCI√ìN FINAL Y DEFINITIVA
                                    "vo2max_ml_min_kg" to record.vo2MillilitersPerKilogramMinute,
                                    "measurement_method" to record.measurementMethod.toString(),
                                    "source" to record.metadata.dataOrigin.packageName,
                                    "change_type" to "UPSERT"
                                ))
                                Log.d(TAG, "  + VO2 Max change detected")
                            }
                        }
                    }
                }
                is DeletionChange -> {
                    deletions.add(change.recordId)
                    Log.d(TAG, "  - Deletion detected: ${change.recordId}")
                }
            }
        }

        // ACTUALIZAR CONDICI√ìN DE "NO HAY CAMBIOS"
        if (weightChanges.isEmpty() && exerciseChanges.isEmpty() && sleepChanges.isEmpty() && vo2MaxChanges.isEmpty() && deletions.isEmpty()) {
            Log.d(TAG, "‚ÑπÔ∏è No hay cambios desde √∫ltimo export")
            tokenManager.saveChangesToken(changesResponse.nextChangesToken)
            return
        }

        val timestamp = LocalDateTime.now().format(DateTimeFormatter.ofPattern("yyyy-MM-dd_HH-mm"))
        val fileName = "health_data_AUTO_DIFF_${timestamp}.json"

        // ACTUALIZAR LLAMADA AL SERIALIZER DIFERENCIAL CON VO2 MAX
        val jsonContent = generateDifferentialJSON(weightChanges, exerciseChanges, sleepChanges, vo2MaxChanges, deletions)

        saveToDownloads(fileName, jsonContent)
        tokenManager.saveChangesToken(changesResponse.nextChangesToken)

        // ACTUALIZAR LOG FINAL
        Log.d(TAG, "‚úÖ Export diferencial: ${weightChanges.size} weight + ${exerciseChanges.size} exercises + ${sleepChanges.size} sleep + ${vo2MaxChanges.size} VO2 Max + ${deletions.size} deletions")
    }

    private fun saveToDownloads(fileName: String, content: String) {
        try {
            Log.d(TAG, "Guardando archivo: $fileName")
            val downloadsDir = Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DOWNLOADS)
            val exportFolder = File(downloadsDir, EXPORT_FOLDER)

            if (!exportFolder.exists()) {
                exportFolder.mkdirs()
                Log.d(TAG, "Carpeta creada: ${exportFolder.absolutePath}")
            }

            val file = File(exportFolder, fileName)
            FileWriter(file).use { writer ->
                writer.write(content)
            }

            Log.d(TAG, "‚úÖ Archivo guardado: ${file.absolutePath}")
            Log.d(TAG, "üìç Ubicaci√≥n: Downloads/$EXPORT_FOLDER/$fileName")

        } catch (e: Exception) {
            Log.e(TAG, "‚ùå Error guardando archivo localmente", e)
            throw e
        }
    }

    // LECTURA DE VO2 MAX
    private suspend fun readVo2MaxRecords(
        healthConnectManager: HealthConnectManager,
        startTime: Instant,
        endTime: Instant
    ): List<Vo2MaxRecord> {
        return try {
            healthConnectManager.readVo2MaxRecords(startTime, endTime)
        } catch (e: Exception) {
            Log.e(TAG, "Error reading VO2 Max records", e)
            emptyList()
        }
    }

    private fun ExerciseSessionRecord.toExportMap(sessionData: ExerciseSessionData, nameGetter: (Int) -> String, emojiGetter: (Int) -> String): Map<String, Any?> {
        val durationMinutes = try { java.time.Duration.between(startTime, endTime).toMinutes() } catch (e: Exception) { 0L }
        return mapOf(
            "session_id" to metadata.id,
            "title" to (title ?: "Exercise Session"),
            "exercise_type" to exerciseType,
            "exercise_type_name" to nameGetter(exerciseType),
            "exercise_emoji" to emojiGetter(exerciseType),
            "start_time" to startTime.toString(),
            "end_time" to endTime.toString(),
            "duration_minutes" to (sessionData.totalActiveTime?.toMinutes() ?: durationMinutes),
            "total_steps" to sessionData.totalSteps,
            "distance_meters" to sessionData.totalDistance?.inMeters,
            "calories_burned" to sessionData.totalEnergyBurned?.inCalories,
            "avg_heart_rate" to sessionData.avgHeartRate,
            "max_heart_rate" to sessionData.maxHeartRate,
            "min_heart_rate" to sessionData.minHeartRate,
            "data_origin" to metadata.dataOrigin.packageName,
            "has_detailed_data" to true,
            "change_type" to "UPSERT"
        )
    }

    private fun SleepSessionRecord.toExportMap(stageNameGetter: (Int) -> String): Map<String, Any?> {
        val durationMinutes = try { java.time.Duration.between(startTime, endTime).toMinutes() } catch (e: Exception) { 0L }
        val stagesMap = stages.map { stage ->
            mapOf(
                "start_time" to stage.startTime.toString(),
                "end_time" to stage.endTime.toString(),
                "stage_type" to stage.stage,
                "stage_name" to stageNameGetter(stage.stage)
            )
        }
        return mapOf(
            "session_id" to metadata.id,
            "start_time" to startTime.toString(),
            "end_time" to endTime.toString(),
            "duration_minutes" to durationMinutes,
            "title" to (title ?: "Sleep Session"),
            "notes" to notes,
            "stages" to stagesMap,
            "source" to metadata.dataOrigin.packageName,
            "change_type" to "UPSERT"
        )
    }

    private fun generateDifferentialJSON(
        weightChanges: List<Map<String, Any?>>,
        exerciseChanges: List<Map<String, Any?>>,
        sleepChanges: List<Map<String, Any?>>,
        vo2MaxChanges: List<Map<String, Any?>>,
        deletions: List<String>
    ): String {
        return buildString {
            append("{\n")
            append("  \"export_type\": \"AUTO_DIFFERENTIAL\",\n")
            append("  \"timestamp\": \"${LocalDateTime.now().format(DateTimeFormatter.ISO_LOCAL_DATE_TIME)}\",\n")
            append("  \"data_source\": \"Samsung Health Only (Filtered)\",\n")
            append("  \"storage_location\": \"Local - Downloads/$EXPORT_FOLDER\",\n")
            append("  \"auto_sync_compatible\": true,\n")
            append("  \"last_export_time\": \"${java.time.Instant.ofEpochMilli(tokenManager.getLastExportTime())}\",\n")

            // Secci√≥n Weight Changes
            append("  \"weight_changes\": {\n")
            append("    \"count\": ${weightChanges.size},\n")
            append("    \"data\": [\n")
            weightChanges.forEachIndexed { index, record ->
                append("      {\n")
                record.forEach { (key, value) ->
                    val valueStr = when (value) {
                        is String -> "\"$value\""
                        is Double -> String.format("%.2f", value)
                        null -> "null"
                        else -> value.toString()
                    }
                    append("        \"$key\": $valueStr")
                    if (key != record.keys.last()) append(",")
                    append("\n")
                }
                append("      }")
                if (index < weightChanges.size - 1) append(",")
                append("\n")
            }
            append("    ]\n")
            append("  },\n")

            // Secci√≥n Exercise Changes
            append("  \"exercise_changes\": {\n")
            append("    \"count\": ${exerciseChanges.size},\n")
            append("    \"data\": [\n")
            exerciseChanges.forEachIndexed { index, session ->
                append("      {\n")
                session.forEach { (key, value) ->
                    val valueStr = when (value) {
                        is String -> "\"$value\""
                        is Double -> String.format("%.2f", value)
                        null -> "null"
                        else -> value.toString()
                    }
                    append("        \"$key\": $valueStr")
                    if (key != session.keys.last()) append(",")
                    append("\n")
                }
                append("      }")
                if (index < exerciseChanges.size - 1) append(",")
                append("\n")
            }
            append("    ]\n")
            append("  },\n")

            // Secci√≥n Sleep Changes
            append("  \"sleep_changes\": {\n")
            append("    \"count\": ${sleepChanges.size},\n")
            append("    \"data\": [\n")
            sleepChanges.forEachIndexed { index, session ->
                append("      {\n")
                session.forEach { (key, value) ->
                    val valueStr = when (value) {
                        is String -> "\"$value\""
                        is List<*> -> {
                            val stages = value as List<Map<String, Any?>>
                            buildString {
                                append("[\n")
                                stages.forEachIndexed { stageIndex, stage ->
                                    append("          {")
                                    stage.entries.forEachIndexed { entryIndex, (k, v) ->
                                        append("\"$k\": ")
                                        when (v) {
                                            is String -> append("\"$v\"")
                                            else -> append("\"$v\"")
                                        }
                                        if (entryIndex < stage.size - 1) append(", ")
                                    }
                                    append("}")
                                    if (stageIndex < stages.size - 1) append(",")
                                    append("\n")
                                }
                                append("        ]")
                            }
                        }
                        null -> "null"
                        else -> value.toString()
                    }
                    append("        \"$key\": $valueStr")
                    if (key != session.keys.last()) append(",")
                    append("\n")
                }
                append("      }")
                if (index < sleepChanges.size - 1) append(",")
                append("\n")
            }
            append("    ]\n")
            append("  },\n")

            // NUEVA SECCI√ìN: VO2 MAX CHANGES
            append("  \"vo2_max_changes\": {\n")
            append("    \"count\": ${vo2MaxChanges.size},\n")
            append("    \"data\": [\n")

            vo2MaxChanges.forEachIndexed { index, record ->
                append("      {\n")
                record.forEach { (key, value) ->
                    val valueStr = when (value) {
                        is String -> "\"$value\""
                        is Double -> String.format("%.2f", value)
                        null -> "null"
                        else -> value.toString()
                    }
                    append("        \"$key\": $valueStr")
                    if (key != record.keys.last()) append(",")
                    append("\n")
                }
                append("      }")
                if (index < vo2MaxChanges.size - 1) append(",")
                append("\n")
            }
            append("    ]\n")
            append("  },\n")

            // Secci√≥n Deletions
            append("  \"deletions\": {\n")
            append("    \"count\": ${deletions.size},\n")
            append("    \"record_ids\": [\n")

            deletions.forEachIndexed { index, id ->
                append("      \"$id\"")
                if (index < deletions.size - 1) append(",")
                append("\n")
            }

            append("    ]\n")
            append("  }\n")
            append("}")
        }
    }

    private fun getExerciseTypeName(exerciseType: Int): String {
        return when (exerciseType) {
            0 -> "Unknown"
            4 -> "Biking"
            33 -> "Running"
            45 -> "Strength Training"
            49 -> "Swimming (Pool)"
            53 -> "Walking"
            57 -> "Yoga"
            else -> "Other ($exerciseType)"
        }
    }

    private fun getExerciseTypeEmoji(exerciseType: Int): String {
        return when (exerciseType) {
            4 -> "üö¥"
            33 -> "üèÉ"
            45 -> "üí™"
            49 -> "üèä"
            53 -> "üö∂"
            57 -> "üßò"
            else -> "üèãÔ∏è"
        }
    }
}